########################################
## Copy-paste to start
########################################
    .text
        .globl __start
__start:

End:
    li $v0, 10
    syscall #The end!

.data
endl: .asciiz "\n"

########################################
########################################


########################################
# Πως γραφουμε bytes και words
########################################

bytes: .byte 0x01, 0x02, 0x03, 0x04, 0x81, 0x82, 0x83, 0x84
words: .word 0x12345678, 0x87654321

########################################
########################################

Syscalls για strings, ints, floats
Για κληση συναρτησεων κανω jal _ονομα-συναρτησης_
########################################
# STRING
########################################
read_string_and_print:
    li $v0, 8 #syscall for read_str
    la $a0, string #buffer δηλωνεται στο data με παυλες
    li $a1, 11 #length + 1
    syscall

    li $v0, 4 #syscall for print_str
    la $a0, string #load adress 
    syscall

    j $ra

.data
    string: .asciiz "----------"

Για να σταματησω στον 5το χαρακτηρα:

    la $a0, string #load adress
    sb $zero 5($a0) #stop at the fifth char
    syscall

Για να διαβασω απο ενα string εναν εναν τους char:
    lbu $s0, buffer($t2)

    ή
    
    lb $t2, 0($t0)          # get str[i]
    Μετα απο print_str το $α0 εχει τον δεικτη στην αρχη του string οποτε το $τ0 ειναι ενας δεικτης που δειχνει σε καθε
    θεση του πινακα και μπορουμε να τον αυξανουμε κατα ενα για να παρουμε ξεχωριστα καθε char
       .
    addi $t2, $t2, 1#Update the counter    

Για να κανω store ενα char σε ενα buffer
    sb $s0, buffer($t2)

########################################
# INTEGER
########################################
read_int_and_print:
    li $v0, 5 #syscall for read_int
    syscall

    move $a0, $v0
    move $t0, $v0
    
    li $v0, 1 #syscall for print_int
    syscall

    li $v0, 4 #syscall for print_str
    la $a0, endl 
    syscall
    j $ra


########################################
# FLOAT
########################################
read_float_and_print:
    li $v0, 6 # read float
    syscall

    mov.s $f12, $f0 # print float
    li $v0, 2
    syscall

    li $v0, 4 #syscall for print_str
    la $a0, endl 
    syscall
    j $ra

########################################
# FLOAT INSTRUCTIONS
########################################
Τους float στο data τους δηλωνω ως .float

move => mov.s 
mul => mul.s
div => div.s παιρνει κανονικα αποτελεσμα σε fd
li => l.s
bc1t 0, label (δεν θελει συνθηκη ειναι σαν j)
bc1f

Εαν θελω να παρω εναν int να τον μετατρεψω σε float και να τον αποθηκευσω σε float reg κανω αυτες τις δυο εντολες με την σειρα:\
στα fd, fs βαζω δυο φορες τον ιδιο καταχωρητη rd

mtc1 rt, rd: για µεταφορά περιεχοµένου από καταχωρητή γενικής χρήσης σε καταχωρητή κινητής υποδιαστολής
mfc1 $t0, $f0 μπαινουν ετσι
cvt.s.w fd, fs: για µετατροπή από αναπαράσταση ακεραίου σε αναπαράσταση κινητής υποδιαστολής

Επισης
c.lt.s $f1, $f0 συγκρινει εαν f1 < 
c.eq.s $f0, $f2 ελεγχει εαν f0 == f2

προσιμο 1bit 0, αν ειναι 1 το bit τοτε ο αριθμος ειναι αρνητικος
εκθετης 8bit 1-8 ισουται με (real_exp + bias) πολωση = 127
κλασμα 23bit 9-32

Απειρα: εκθετης 11111111, κλασμα ολο 0
ΝαΝ: εκθετης 11111111, κλασμα != ολο 0



zer_f:   .float 0.0
m_inf:   .word 0xff800000
p_inf:   .word 0x7f800000
nan:     .word 0x7fffffff

########################################
# DIV/MUL
########################################

mfhi => υπολοιπο/ ψηλα 32bit
mflo => πηλικο/ χαμηλα 32bit

########################################
# FUNCTIONS
########################################
Βασικος κορμος δεσμευω και αποδεσμευω θεσεις στην στοιβα.
Σωζω τον $ra εαν κατηγορια != φυλλου

    addi $sp, $sp, -4 # adjust stack for an item
    sw $ra, 0($sp) # save return address
    .
    τυχων $s registers
    .
    .
    lw $ra, 0($sp) # restore return address
    addi $sp, $sp, 4 # pop one item from stack

Αποτελεσματα επιστρεφονται $v1, $v0

########################################
# Ολιγον θεωρητικα...
########################################
Φορτωσε σε καταχωρητη => load 
Αποθηκευσε στην μνημη => store

Οι εντολές απέχουν µεταξύ τους 4 byte []

Τα δεδοµένα χρήστη αρχίζουν στη δεκαεξαδική διεύθυνση 0x10010000

sb οχι επεκταση προσημου

Πως διαβαζω ενα word: παω δεξια στο πρωτο byte και διαβαζω απο αριστερα προς τα δεξια, δλδ 
το 04030201 ειναι 01020304

Ευθυγραμμιση = λεξη αποθηκευεται σε διαευθυνση μνημης πολλαπλασια του 4

Στους δεκαεξαδικους αριθμους τα μηδενικα μπροστα παραλληπονται 

########################################
########################################




